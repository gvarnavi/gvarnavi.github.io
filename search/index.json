[{"content":"üëã Hi there! My name is Georgios, which I\u0026rsquo;ve been told sounds uncannily similar to how one would pronounce \u0026ldquo;George(ous)\u0026rdquo;, but I go by George.\nI\u0026rsquo;m a postdoctoral Miller research fellow working primarily in materials science and condensed-matter physics, but I\u0026rsquo;m easily distracted so you might see various (seemingly) unrelated projects/musings here.\nFeel free to look around and if anything catches your eye, or you think we could work together, please leave a comment or drop me a line.\nIf you\u0026rsquo;re just here for my CV, you can see it here, or download a printable version here.\nResearch Interests Electron Hydrodynamics Advanced Characterization Spatially Resolved Transport Materials Science Pedagogy Musings Tilings and Projection Set Algorithms Generative Art Counting Digits of Pi Yoga Poses Constellations ","href":"/","title":"Home"},{"content":"","href":"/research-topics/","title":"Research Topics"},{"content":"For a complete list of publications, please see my Google Scholar profile.\nIf you\u0026rsquo;re just here for my CV, you can see it here, or download a printable version here.\n","href":"/publications/","title":"Publications"},{"content":"I have always hated making slide decks. I find them hard to make simple-enough to be readable/elegant, yet detailed-enough to be informative. After years of fiddling with unsatisfying designs, I settled on a split-slide format I was happy with and re-used for a couple of years. I eventually got tired of it.\nRecently, I started using a ReactJS+ObservableHQ+Docusaurus workflow to make interactive presentations which are (relatively) easy to maintain and deploy. In the spirit of open-source science, this page lists these presentations as-well as a post on some tips and tricks to getting started.\n","href":"/presentations/","title":"Presentations"},{"content":"","href":"/musings/","title":"Musings"},{"content":"I\u0026rsquo;m originally from Cyprus where I grew up and studied before moving to the US to obtain my BS in materials science \u0026amp; engineering and BS in civil \u0026amp; environmental engineering from MIT in 2017. Enamored with the Boston weather, I decided to stay at MIT to pursue my graduate studies in the department of Materials Science, where I recently defended my thesis entitled \u0026ldquo;Electron Hydrodynamics in Crystalline Solids\u0026rdquo;.\nCurrently, I\u0026rsquo;m a postdoctoral Miller research fellow at the University of California, Berkeley \u0026ndash; co-hosted by Prof. Mary Scott in MSE and Prof. Joel Moore in Physics \u0026ndash; where I\u0026rsquo;m developing new computational imaging modalities to observe current densities in anisotropic electron fluids with high spatial resolution using a transmission electron microscope.\nWhen I don\u0026rsquo;t have my science cap on, I enjoy camping, teaching generative art, and singing along to musical theater videos.\n","href":"/about/","title":"About"},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/authors/georgiosvarnavides/","title":"georgiosvarnavides"},{"content":"Georgios Varnavides, Stephanie Ribet, Reed Yalisove, Joel Moore, Colin Ophus, Mary Scott.\n2023 Jul 24, Interactive presentation link, Conference proceedings link\nAbstract While the observation of magnetic structure with nanometer spatial resolution has been successfully achieved with various transmission electron microscopy (TEM) techniques such as Lorentz TEM, off-axis electron holography, differential phase contrast (DPC), and more recently, Lorentz scanning TEM, atomic-scale imaging of magnetization remains challenging. This can be traced back to the extremely small phase-shifts acquired by the electron beam due to the magnetic vector potential, \\( \\boldsymbol{A}(x,y,z) \\), compared to those acquired due to the electrostatic potential of the sample, \\( V(x,y,z) \\):\n\\[ \\phi(x,y) = \\phi_e(x,y) + \\phi_m(x,y) = \\sigma \\int V(x,y,z) dz - \\frac{e}{\\hbar} \\int A_z(x,y,z) dz, \\] where \\( \\sigma \\) is the interaction parameter, \\( e \\) is the elementary charge, and \\( \\hbar \\) is the reduced Planck\u0026rsquo;s constant.\nRecent studies have addressed this inherent signal-to-noise challenge via kernel-filtering and unit-cell averaging of DPC measurements, centre-of-mass and principal component analysis, and more recently, Fourier-filtering of ptychographically-reconstructed phase images. While these techniques enable atomic-scale imaging of magnetization for the studied systems, they require prior knowledge of the magnetic ordering in the system and are unlikely to generalize well to non-periodic systems.\nIn this work, we introduce a novel ptychographic algorithm to simultaneously reconstruct the electrostatic and magnetic vector potential from two sets of diffraction intensity measurements, in which the sign of the magnetic contribution to the phase is reversed, e.g., by flipping the sample 180 degrees. Separating the electrostatic and magnetic contributions to the retrieved phase shifts from two sets of measurements is routinely performed in off-axis electron holography:\n\\[ \\phi_e = \\frac{1}{2}\\left(\\phi^{\\rightarrow}+\\phi^{\\leftarrow}\\right) \\qquad, \\qquad \\phi_m = \\frac{1}{2}\\left( \\phi^{\\rightarrow} - \\phi^{\\leftarrow}\\right), \\] and indeed such a \u0026ldquo;background-subtraction\u0026rdquo; technique can be applied to ptychographic reconstructions mutatis mutandis. However, the procedure is prone to amplify noise in the magnetic potential phase by subtracting two potentially noisy reconstructions.\nBy contrast, our algorithm, which is implemented in the open-source 4D-STEM processing and analysis toolkit py4DSTEM, uses a physically inspired forward model for the overlap projection which distinguishes between the ‚Äúforward‚Äù and ‚Äúreverse‚Äù measurement directions by conjugating the complex magnetic potential object. This enables high signal-to-noise reconstructions, while also allowing for different regularization constraints on the electrostatic and magnetic potential objects, e.g., using a multislice propagator for the electrostatic potential object while assuming the magnetic potential is a single-slice pure-phase object.\nWe illustrate the performance of the algorithm on simulated datasets for antiferromagnetic (AFM) NiO lattices, chosen due to its high N√©el temperature of 523K and insulating collinear antiferromagnetic phase of alternating ferromagnetic (111) planes. Figure 1 shows the electrostatic and magnetic contributions to the phase along the beam direction for bulk antiferromagnetic NiO, calculated using collinear density functional theory. Due to the orders of magnitude difference between the two scattering signals, the ‚Äúbackground subtraction‚Äù reconstruction for a simulated dataset with finite dose is noisy and quantitatively incorrect, recovering a lower phase shift than the simultaneous reconstruction algorithm.\nTo further demonstrate the robustness of the reconstruction algorithm on non-periodic structures, we consider two types of oxygen-terminated twin boundaries (TB) in NiO with different antiferromagnetic ordering (Figure 2). First, note that while the twin-boundary is immediately obvious in the reconstructed electrostatic potential (or equivalently in HRTEM/STEM imaging), certain antiferromagnetic orderings across the twin boundary give similar magnetic phase contributions as bulk NiO (in our chosen zone-axis). Conversely, conventional imaging techniques cannot differentiate between different magnetic orderings across the twin boundary, in contrast to the simultaneous reconstruction algorithm.\nFinally, we comment on the choice of experimental design parameters, such as convergence angle and sample thickness, as-well as reconstruction parameters, such as low-pass filtering and various projection-set algorithms, as means to amplify the magnetic signal, while sacrificing resolution in the electrostatic potential.\n2023 Jul 24, Interactive presentation link, Conference proceedings link\n","href":"/presentations/mm23-simultaneous/","title":"MM23 - Simultaneous Reconstructions"},{"content":"Observable Notebooks First things first: if you want an interactive presentation you need to create (or re-use!) interactive components or widgets. These need to run client-side and would ideally be packaged as react components. I like using observablehq to do this, a reactive notebook environment for javascript code.\nAdmittedly, coding in javascript is a bit of a learning curve but I have found the scijs family of packages as-well as numjs to be a fairly good numpy replacement for N-dimensional array scientific computing.\nObservablehq ships with lightweight interface components such as buttons, sliders, dropdowns, etc., to facilitate interactive widgets, a concise plotting API, and the ability to fork/import other public notebooks.\nWhen building exploratory observable notebooks, I like to interweave markdown text and interactive displays leaving all the utility functions at the bottom, see e.g. this 4dstem multislice simulation notebook. I then create a separate (untitled) notebook which simply imports the necessary visualizations/widgets to export as I\u0026rsquo;d like to appear in the presentation, see e.g. this 4dstem multislice simulation component.\nReact Components Once you\u0026rsquo;re satisfied with your interactive component, you need to export it as a React component to embed in our presentation. Observablehq provides many ways to embed notebook cells onto websites, but we\u0026rsquo;re interested in embedding the \u0026ldquo;Entire notebook\u0026rdquo; using \u0026ldquo;Runtime with React\u0026rdquo; in the pop-up window.\nEach interactive component must then be yarn-installed in your docusaurus website (see below) and the minimal code the pop-up windown prompts you to copy should be placed in the src directory, see e.g. here.\nAt this point, if you created the component yourself, you can remove the \u0026lt;p\u0026gt; tag with the attribution banner. Finally, if you\u0026rsquo;ve modified the notebook a few times, make sure to install the correct pinned version of the notebook.\nDocusaurus Website The actual website is made using Docusaurus, a wonderful documentation-site builder using React and MDX. This will give us site-navigation as-well as a sidebar \u0026ldquo;for-free\u0026rdquo; where each documentation markdown page is written in MDX, allowing you to embed React components directly into markdown text, see e.g. here.\nA number of configuration options can be used to make the website look more \u0026ldquo;presentation-like\u0026rdquo;:\nHideable sidebar Hideable table-of-contents on each doc page CSS-styling to hide observable \u0026ldquo;inspector\u0026rdquo; cells Tabs and details elements were used to mimic slide animations Finally, you can deploy your website using a Jamstack provider. I like using Github pages, and you can see the full source-code for an example presentation here.\n","href":"/presentations/interactive-presentations-workflow/","title":"Interactive Presentations Workflow"},{"content":"Introduction As part of my postdoctoral Miller fellowship, I have been developing computational imaging algorithms to recover the phase of an object from diffraction intensity measurements, using a technique called \u0026ldquo;electron ptychography\u0026rdquo;. One of the earliest and most successful algorithms for such phase retrieval is based on projection onto (non-)convex sets, which turns out to also be able to solve a variety of non-convex problems. Perhaps the most fun application is solving a Sudoku puzzle.\nSudoku Puzzles Sudoku puzzles can be viewed as a constraint satisfaction problem, with the following well-known constraints:\nEach row contains only one of each of the numbers 1-9 Each column contains only one of each of the numbers 1-9 Each 3x3 \u0026lsquo;block\u0026rsquo; contains only one of each of the numbers 1-9 The solution must be consistent with a (minimum) set of pre-defined grid numbers If we represent a Sudoku grid using a binary 9x9x9 array, where if the element \\( Q\\left(i,j,k \\right) \\) is equal to 1, then we place the number \\( k \\) on the \\( \\left(i,j\\right) \\) tile, then we can formalize these constraints as:\n\\[ \\begin{align} \\sum_{k=1}^9 Q(i,j,k) \u0026= 1 \\quad \\forall i,j \\\\ \\sum_{i=1}^9 Q(i,j,k) \u0026= 1 \\quad \\forall j,k \\\\ \\sum_{j=1}^9 Q(i,j,k) \u0026= 1 \\quad \\forall i,k \\\\ \\sum_{i=1}^3 \\sum_{j=1}^3 Q(i+U,j+V,k) \u0026= 1 \\quad \\forall k \\text{ and } \\; U,V \\in \\left\\{ 0,3,6 \\right \\} \\\\ Q(i,j,:) \u0026= \\gamma_{i,j} \\quad \\forall i,j \\in J', \\end{align} \\]\nwhere \\( \\gamma_{i,j} \\) is the unit-vector representing the known symbols in \\( J'\\). Note that the first constraint, namely that the sum over the vector of symbols must equal 1 for each tile, combined with the fact that our representation only allows binary values of 0 or 1, ensures we have a single symbol at each cell.\nAs formulated above, the problem lends itself well to Linear Programming solutions, e.g. the SolveSudokuPuzzle resource function, which has the minimal source code:\nSolveSudokuPuzzle[known_SparseArray] := Module[{z,sudokuConstraints,vars,knownConstraints,res,i,j,k,l,n,m=Length[known]}, n = Sqrt[m]; sudokuConstraints={ Table[{Total[z[i,j]]==1,0\\[VectorLessEqual]z[i,j]\\[VectorLessEqual]1,z[i,j]\\[Element]Vectors[m,Integers]},{i,m},{j,m}], Table[{Sum[z[i,j],{j,m}]==1,Sum[z[j,i],{j,m}]==1},{i,m}], Table[Sum[z[i+k,j+l],{k,m},{l,m}]==1,{i,0,m-n,n},{j,0,m-n,n}] }; knownConstraints=MapThread[Indexed[z@@#1,Abs[#2]]==If[#2\u0026lt;0,0,1]\u0026amp;,{known[\u0026#34;NonzeroPositions\u0026#34;],known[\u0026#34;NonzeroValues\u0026#34;]}]; vars=Flatten[Table[z[i,j],{i,m},{j,m}]]; LinearOptimization[0,{sudokuConstraints,knownConstraints},vars] ] Back to projection set algorithms, Veit Elser and co-authors showed that the Sudoku constraints can be interpreted as projection operators to appropriate non-convex sets and solved using a specific projection set algorithm called the \u0026ldquo;difference map\u0026rdquo; algorithm. We will skip most of the implementation details, but as an example the single-symbol constraint for each tile can be implemented as a projection operator which sets the maximum-value index to 1 and the rest of the elements of the vector to zero, i.e.:\nprojectToUnitVector[vector_]:=UnitVector[9,First@FirstPosition[vector,Max[vector],{1},Heads-\u0026gt;False]] squareProjection[array_]:=Map[projectToUnitVector,array,{2}] Here\u0026rsquo;s a fun online demo of the projection sets algorithm at work solving Sudoku puzzles. For more information, see this wonderfully-clear thesis on the topic.\nConstrained Tilings Considering the sets satisfying the above 5 constraints are highly non-convex, I was curious to see if projection set algorithms could solve another favorite problem of mine which can be formulated using linear constraints, namely that of constrained tilings.\nThe problem is formulated as follows: given an \\( \\left(n,m\\right) \\) target image, and a set of \\( L \\) (colored) tiles, find the arrangement of tiles which most closely approximates the target image\u0026rsquo;s color values, while respecting the topological constraints between adjacent tiles. For example, in the set of 24 grayscale \u0026ldquo;Smith\u0026rdquo; tiles shown below, the tiles in the first two rows in the third column are allowed to be placed on top of each other, but the tiles in the first two rows of the first column are not.\nFor the sake of brevity, we once again omit most implementation details, but briefly the projections are given by:\nSimilar to the Sudoku puzzles, we represent our tiling using an \\( \\left(n,m,L\\right) \\) array and only allow one tile per pixel. As such, the first constraint and thus projection operator is the same as above. The target-image-constistency constraint we choose is also fairly straightforward: we simply weigh the current iteration vector at each pixel according to a Gaussian kernel centered on the tile\u0026rsquo;s color value minus the target image color value at that pixel. The tiling constraint projection is perhaps less obvious. Denote the set of \\( M \\) topological constraints acting on a vectorized version of our array \\( \\vec{x} = \\text{vec}\\left(Q(i,j,t)\\right) \\), using the \\( \\left(M,n \\times m \\times L\\right) \\) matrix \\( C \\), such that \\( C \\cdot \\vec{x} = 0 \\). The orthogonal projector onto the nullspace of the topological constraints is therefore given by: \\[ P_{C}(\\vec{x}) = \\left(\\mathbb{I} - C^+\\cdot C \\right)\\cdot \\vec{x}, \\] where \\( C^+ \\) denotes the Moore-Penrose pseudoinverse of the topological constraints matrix. We implement these three projections using the \u0026ldquo;relax-reflect-reflect\u0026rdquo; algorithm (a variant of the \u0026ldquo;difference-map\u0026rdquo; algorithm, with a tunable step-size) and, lo and behold, it works!\nI hope you find watching the algorithm trying to climb out of a local minimum as mesmerizing as I do! If you are curious about the source code, here is a cloud notebook.\n","href":"/musings/tilings-and-projection-set-algorithms/","title":"Tilings and Projection Set Algorithms"},{"content":"","href":"/publications/advanced-optical-materials-2200933-2022/","title":"Advanced Optical Materials 2200933 (2022)"},{"content":"","href":"/publications/phys-rev-mater-6-083802-2022/","title":"Phys Rev Mater 6, 083802 (2022)"},{"content":"Introduction As part of the MIT course 3.029 I taught in the spring of 2022, we held optional coding \u0026ldquo;get-togethers\u0026rdquo; once a week, alternating between \u0026ldquo;Data-Visualization Hour\u0026rdquo; and \u0026ldquo;Code Show and Tell\u0026rdquo;. In particular, the week of Pi day happened to fall on \u0026ldquo;Code Show and Tell\u0026rdquo; and the students thought it\u0026rsquo;d be fun to code up one of the craziest Pi-related phenomena I know.\nThis is very beautifully explained in the 3Blue1Brown video below:\nMathematica SE solution First, note that this exact question was asked on the Mathematica SE in 2020 - with a very natural numeric solution using DiscreteVariables in NDSolveValue.\nnumericSolution[d_] := Module[{ collisions = 0, m1 = 1, m2 = 100^(d - 1), x10 = 1, x20 = 2, v10 = 0, v20 = -1, tmax = 20, etot, newvelocity, vsol, sol }, etot = m1 v10^2 + m2 v20^2; newvelocity[vv1_, vv2_] := Block[{tsol}, tsol = Quiet[Solve[{m1 vn1 + m2 vn2 == m1 vv1 + m2 vv2, m1 vn1^2 + m2 vn2^2 == etot}, {vn1, vn2}]]; {vn1, vn2} /. If[Sign[tsol[[1, 1, 2]]] != Sign[vv1], tsol[[1]], tsol[[2]]] ]; sol = NDSolveValue[{ x1\u0026#39;[t] == v1[t], x2\u0026#39;[t] == v2[t], x1[0] == x10, x2[0] == x20, v1[0] == v10, v2[0] == v20, WhenEvent[x1[t] == x2[t], { collisions += 1, vsol = newvelocity[v1[t], v2[t]], v1[t] -\u0026gt; vsol[[1]], v2[t] -\u0026gt; vsol[[2]] }], WhenEvent[x1[t] == 0, { collisions += 1, v1[t] -\u0026gt; -v1[t] }]}, {x1, x2, v1, v2}, {t, 0, tmax}, DiscreteVariables -\u0026gt; {v1, v2}]; Echo[collisions]; sol ] Event-Based Elastic Collisions It\u0026rsquo;s instructive however to code this up from scratch using simple elastic collisions!\nCollision Times Consider the collison between two particles, assumed to be a distance \\( 2r \\) apart. The trajectories of the two particles can be computed using their positions, instantaneous velocities, and time:\ntrajectory1 = x1 + v1 t; trajectory2 = (x1 + Œîx) + (v1 + Œîv) t; Their separation squared is therefore given by:\nseparationSquared = Simplify[With[{delta = trajectory2 - trajectory1}, delta . delta]] \\[ (\\text{$\\Delta $x}+\\text{$\\Delta $v} t).(\\text{$\\Delta $x}+\\text{$\\Delta $v} t) \\] The Wolfram Language makes no assumptions about the dot products since we\u0026rsquo;ve kept all our variables symbolic, so let\u0026rsquo;s help it out a bit by introducing simple multiplication rules:\nseparationSquared = Distribute[separationSquared] //. { ( t a_ ) . ( t b_ ) :\u0026gt; t^2 a . b, ( a_ ) . ( t b_ ) :\u0026gt; t a . b , ( t a_ ) . ( b_ ) :\u0026gt; t a . b, ( Œîv . Œîx ) :\u0026gt; ( Œîx . Œîv ) } \\[ \\text{$\\Delta $x}.\\text{$\\Delta $x}+\\text{$\\Delta $v}.\\text{$\\Delta $v} t^2+2 t \\text{$\\Delta $x}.\\text{$\\Delta $v} \\] We\u0026rsquo;re now ready to find the collision times, i.e. the times \\( t \\) when the expression for the squared distance above equals \\( 4r^2 \\).\n{firstCollision, secondCollision} = t /. Simplify[Solve[separationSquared == (2 r)^2, t]] \\[ \\left\\{-\\frac{\\text{$\\Delta $x}.\\text{$\\Delta $v}+\\sqrt{(\\text{$\\Delta $x}.\\text{$\\Delta $v})^2+\\text{$\\Delta $v}.\\text{$\\Delta $v} \\left(4 r^2-\\text{$\\Delta $x}.\\text{$\\Delta $x}\\right)}}{\\text{$\\Delta $v}.\\text{$\\Delta $v}}, \\frac{\\sqrt{(\\text{$\\Delta $x}.\\text{$\\Delta $v})^2+\\text{$\\Delta $v}.\\text{$\\Delta $v} \\left(4 r^2-\\text{$\\Delta $x}.\\text{$\\Delta $x}\\right)}-\\text{$\\Delta $x}.\\text{$\\Delta $v}}{\\text{$\\Delta $v}.\\text{$\\Delta $v}} \\right\\} \\] Note that since our equation is quadratic in time, there are two collision solutions. It\u0026rsquo;s probably easiest to show their difference graphically using an example:\nWe\u0026rsquo;re interested in the first collision time, when the particles first touch: The second collision time corresponds to the time the particles have separated again post-collision, had they been allowed to pass straight through each other: We can now write a function which returns the collision time:\nparticleParticleCollisionTime[{p1 : {m1_, x1_, v1_}, p2 : {m2_, x2_, v2_}}] := Block[{dummyMass, dx, dv, dxdv, dvdv, dxdx, rootTerm}, {dummyMass, dx, dv} = p2 - p1; dxdv = dx . dv; If[dxdv \u0026gt;= 0, Return[\\[Infinity]]]; dxdx = dx . dx; dvdv = dv . dv; rootTerm = dxdv^2 + (dvdv (1 - dxdx)); If[rootTerm \u0026lt; 0, Return[\\[Infinity]]]; -(dxdv + Sqrt[rootTerm])/dvdv ] Note that we\u0026rsquo;ve assumed the particles have a radius \\( r=1/2 \\) for simplicity and instructed our function to return Infinity if our particles are moving away from each other and will not collide.\nThis allows us to write a simple function to return the position of particles at time \\( t \\):\nparticleStateAtTime[particle : {m_, x_, v_}, time_] := {m, x + time v, v} Velocities Post-Collision The velocities post-collision are given using energy and momentum conservation:\nconservationLaws[1] = { m[1] u[1] + m[2] u[2] == m[1] v[1] + m[2] v[2], 1/2 m[1] u[1]^2 + 1/2 m[2] u[2]^2 == 1/2 m[1] v[1]^2 + 1/2 m[2] v[2]^2 }; Solve[conservationLaws[1], {v[1], v[2]}] \\[ \\begin{matrix} \\left\\{v(1)\\rightarrow u(1),v(2) \\rightarrow u(2)\\right\\} \\\\ \\left\\{ v(1)\\rightarrow \\frac{m(1) u(1)-m(2) u(1)+2 m(2) u(2)}{m(1)+m(2)}, v(2)\\rightarrow \\frac{2 m(1) u(1)-m(1) u(2)+m(2) u(2)}{m(1)+m(2)}\\right\\} \\end{matrix} \\] This generalizes nicely to higher dimensions:\nbounceVelocitiesAfterCollision[{p1 : {m1_, x1_, v1_}, p2 : {m2_, x2_, v2_}}] := Block[{dv = v2 - v1, dx = x2 - x1, deltaV, \\[Mu] = m1 m2/(m1 + m2), \\[Delta]v}, \\[Delta]v = (dv . dx (dx))/dx . dx; { {m1, x1, v1 + (2 \\[Mu])/m1 \\[Delta]v}, {m2, x2, v2 - (2 \\[Mu])/m2 \\[Delta]v} } ] It would be convenient if we could treat particle-wall collisions using our existing framework. To do so, we consider an \u0026ldquo;immovable\u0026rdquo; wall as a stationary object with Infinite mass. This requires we specialize our two functions above using pattern matching (mathematica\u0026rsquo;s analogue of multiple dispatch):\nbounceVelocitiesAfterCollision[{p1 : {\\[Infinity], x1_, v1_}, p2 : {m2_, x2_, v2_}}] := Block[{dv = v2, dx = x2 - x1, deltaV, \\[Delta]v}, \\[Delta]v = (dv . dx (dx))/dx . dx; { {\\[Infinity], x1, v1}, {m2, x2, v2 - 2 \\[Delta]v} } ] bounceVelocitiesAfterCollision[{p1 : {m1_, x1_, v1_}, p2 : {\\[Infinity], x2_, v2_}}] := Block[{dv = -v1, dx = x2 - x1, deltaV, \\[Delta]v}, \\[Delta]v = (dv . dx (dx))/dx . dx; { {m1, x1, v1 + 2 \\[Delta]v}, {\\[Infinity], x2, v2} } ] Colliding Blocks Setup As we alluded to above, we\u0026rsquo;ll consider three \u0026ldquo;blocks\u0026rdquo;:\nAn \u0026ldquo;immovable\u0026rdquo; rigid block (wall) at \\( x = \\{-1/2\\} \\) An initially stationary (blue) block with \\( m = 1 \\), at \\( x = \\{2\\} \\) A (red) block with \\( m = 100^{d-1} \\), at \\( x = \\{5\\} \\), moving to the left with \\( v = \\{-1\\} \\) particleStates[d_] := { {\\[Infinity], {-1/2}, {0}}, {1, {2}, {0}}, {100^(d - 1), {5}, {-1}} } As such, we have two possible collisions to consider:\nBlue block colliding with the wall Blue block colliding with the red block At each iteration, we will:\nCompute the two possible collision times Pick the smallest time Update the positions and velocities post-collision Rinse and repeat findShortestCollisionTime[{t_, particleStates : {wall_, blue_, red_}}] := Block[{wallBlue, blueRed}, wallBlue = particleParticleCollisionTime[{wall, blue}]; blueRed = particleParticleCollisionTime[{blue, red}]; {Min[{wallBlue, blueRed}], Ordering[{wallBlue, blueRed}]} ] bounceParticlesAtShortestCollision[{t_, particleStates : {wall_, blue_, red_}}] := Block[{time, ordering, preWall, preBlue, preRed, post}, {time, ordering} = findShortestCollisionTime[{t, particleStates}]; If[time == \\[Infinity], Return[{t, particleStates}]]; {preWall, preBlue, preRed} = particleStateAtTime[#, time] \u0026amp; /@ particleStates; post = Switch[ordering, {1, 2}, Append[bounceVelocitiesAfterCollision[{preWall, preBlue}], preRed], {2, 1}, Prepend[bounceVelocitiesAfterCollision[{preBlue, preRed}], preWall] ]; {t + time, post} ] The \u0026lsquo;do-nothing\u0026rsquo; clause inside our function above, ensures that if both collision times are Infinity, then the particle state returns unchanged. This allows us to use FixedPointList to conveniently exhaust the simulation until both our blocks fly away towards the right, terminating the simulation:\neventsList[digits_] := N[Most[FixedPointList[ bounceParticlesAtShortestCollision, {0, N[particleStates[digits]]}]]] Visualization Functions Finally, we write two utility functions to build a linear interpolation on the blocks\u0026rsquo; positions given our collisions event list:\npositionsInterpolator[listOfEvents_] := With[{ times = listOfEvents[[All, 1]], positions1D = Transpose[listOfEvents[[All, 2, All, 2, 1]]] }, Table[Interpolation[Transpose[N[{times, positions}]], InterpolationOrder -\u0026gt; 1], {positions, positions1D}] ] visualizeBlocks[t_, times_][{wall_InterpolatingFunction, blue_InterpolatingFunction, red_InterpolatingFunction}] := Graphics[{ {EdgeForm[Directive[Black, Dashed]], FaceForm[None], Rectangle[{-10, -10}, {0, 10}]}, {Blue, Rectangle[{blue[t] - 1/2, -1/2}, {blue[t] + 1/2, 1/2}]}, {Red, Rectangle[{red[t] - 1/2, -1/2}, {red[t] + 1/2, 1/2}]} }, PlotRange -\u0026gt; {{-1, 12}, {-1, 1}}, PlotLabel -\u0026gt; StringTemplate[\u0026#34;Collisions:`1`\u0026#34;][ First[FirstPosition[times, ts_ /; ts \u0026gt; t, {Length[times] + 1}]] - 2] ] Animation We can wrap everything together to produce animations of the sort:\nModule[{ events = eventsList[3], interpolators, times }, times = events[[All, 1]]; interpolators = positionsInterpolator[events]; Animate[visualizeBlocks[t, times][interpolators], {{t, 0, \u0026#34;Time\u0026#34;}, 0, Last[times]}, AnimationRepetitions -\u0026gt; 1, Paneled -\u0026gt; False, AnimationRunning -\u0026gt; False] ] ","href":"/musings/counting-digits-of-pi/","title":"Counting Digits of Pi"},{"content":"Together with some friends in the DMSE department, I\u0026rsquo;ve been teaching a generative art workshop during MIT\u0026rsquo;s Independent Activity Period (IAP) for the past 5 years. IAP 2022 was the fifth* iteration of the workshop (previously taught in 2017 and 2018 with Emma Vargo, 2020 with Amina Matt, Jovana and Nina Andrejevic, and 2021 with Jovana and Nina).\nThe 4-day workshop walks through python and Wolfram Language notebooks, covering the following broad topics:\nGeometric Fractals \u0026amp; L-Systems Strange Attractor \u0026amp; Wallpaper Groups Cellular Automata \u0026amp; Discrete Physical Systems Continuous Physical Systems \u0026amp; Reaction-Diffusion Systems You can find the most recent notebooks on the 2022 workshop website, as well as peruse the 2020 and 2022 workshop galleries.\n* All instructors have recently graduated from MIT. If you\u0026rsquo;re an MIT-affiliate and interested in teaching this in IAP 2023, please reach out \u0026ndash; we will be happy to help and share our notebooks/experience.\n","href":"/musings/generative-art/","title":"Generative Art"},{"content":"","href":"/publications/front-neurosci-16-901108-2022/","title":"Front Neurosci 16:901108 (2022)"},{"content":"","href":"/publications/arxiv2204.06004-2022/","title":"arXiv:2204.06004 (2022)"},{"content":"","href":"/publications/phys-rev-mater-6-045002-2022/","title":"Phys Rev Mater 6, 045002 (2022)"},{"content":"I‚Äôve long been fascinated with transportation maps, and in particular the revolutionary re-design of the london-underground map by Harry Beck in 1933. In his iconic design, which has since been adopted by most transportation maps, Harry Beck deliberately sacrifices geographic accuracy for visual clarity of information - by using equally-spaced stations on straight lines with only 45/90 degree bends.\nIn this Wolfram Community post, we investigate how the local coordinate system is additionally distorted through the years as more stations get added to display the information more clearly.\n","href":"/musings/geographic-map-distortions/","title":"Geograghic Map Distortions"},{"content":"","href":"/publications/phys-rev-mater-5-l091202-2021/","title":"Phys Rev Mater 5, L091202 (2021)"},{"content":"","href":"/publications/nat-phys-17-1216-1220-2021/","title":"Nat Phys, 17, 1216‚Äì1220 (2021)"},{"content":"","href":"/publications/sci-adv-7-eabi6699-2021/","title":"Sci Adv 7, eabi6699 (2021)"},{"content":"","href":"/publications/nat-commun-12-4799-2021/","title":"Nat Commun 12, 4799 (2021)"},{"content":"","href":"/publications/angew-chem-int-ed-2021/","title":"Angew. Chem. Int. Ed. (2021)"},{"content":"At its first meeting in 1922, the International Astronomical Union (IAU), officially adopted the list of 88 constellations that we use today. These include 14 men and women, 9 birds, two insects, 19 land animals, 10 water creatures, two centaurs, one head of hair, a serpent, a dragon, a flying horse, a river and 29 inanimate objects. As many of us have (frustratingly) witnessed first hand while star-gazing - most of these bear little resemblance to their supposed figures. Instead, it is more likely that the ancient constellation-makers meant them to be symbolic, a kind of celestial \u0026ldquo;Hall of Fame\u0026rdquo; for their favorite animals or heroes.\nThis begs two questions I sought to answer with this old post of mine on Wolfram Community:\nCan we \u0026lsquo;do better\u0026rsquo; with Wolfram Language\u0026rsquo;s StarData[] curated data and Machine Learning functionality? What if the ancient constellation-makers were slightly more creative? Say they looked up at the sky, and only saw yoga-poses! ","href":"/musings/yoga-poses-constellations/","title":"Yoga Poses Constellations"},{"content":"In most conductors at room-temperature, electron collisions are akin to billiard balls, resulting in the macroscopic observation of diffusive flow (Ohm\u0026rsquo;s \u0026ldquo;law\u0026rdquo;). Recently, spatially-resolved transport measurements have revealed electrons in strongly-interacting materials can behave akin to classical fluids, confirming theoretical predictions over fifty years old.\nI study these \u0026ldquo;hydrodynamic\u0026rdquo; electron flows across various length scales, from their microscopic origins, to mesoscopic finite-size effects, and to their macroscopic observables. Recently, I was part of a team which imaged these flows in a 3D conductor for the first time, corroborating a newly-proposed electron interaction mechanism mediated by lattice vibrations.\nCurrently, as a postdoctoral Miller research fellow, I\u0026rsquo;m developing computational imaging techniques to correlate such non-uniform current densities with the underlying structure, opening the door to investigating the role of structure and defects in designing near-dissipation-less electronics and inviting questions like \u0026ldquo;does current flow around defects in materials similar to how rivers flow past pebbles? If so, can we engineer them to minimize thermal dissipation?\u0026rdquo;\n","href":"/research-topics/electron-hydrodynamics/","title":"Electron Hydrodynamics"},{"content":"I have long been fascinated by materials characterization, and in-particular the ability to image atoms and nanoscale phenomena at high spatial resolution. One of the most versatile instruments to achieve this is the scanning transmission electron microscope (STEM).\nIn my PhD work, I have collaborated with experimentalists to directly image moir√® superlattices at the interface of 2D/3D materials and investigate phonon localization at the interface between two 2D materials with high-resolution STEM-based techniques.\nCurrently, as a postdoctoral Miller research fellow, I\u0026rsquo;m developing computational imaging techniques to image the induced magnetic fields arising in hydrodynamic electron flows with nanoscale resolution, by developing electron ptychography algorithms to jointly-reconstruct the electrostatic and magnetic-vector potentials.\n","href":"/research-topics/advanced-characterization/","title":"Advanced Characterization"},{"content":"During the course of my PhD, I developed an open-source software package called SpaRTaNS to perform spatially-resolved transport by solving the steady-state Boltzmann transport equation in three real-space and three momentum-space dimensions.\nSpaRTaNS is \u0026ldquo;carrier-agnostic\u0026rdquo; with applications in phonon (heat) transport (e.g thermal interface resistance of semi-coherent interfaces), as-well as electron (charge) transport (e.g the importance of microscopic interactions in electron hydrodynamic flows). SpaRTaNS can be run on anything from a laptop to high-performance computing systems, and provides a flexible API for specifying custom boundary conditions, collision operators, geometries, state spaces, and more.\n","href":"/research-topics/spatially-resolved-transport/","title":"Spatially Resolved Transport"},{"content":"I spend a great deal of my time thinking about pedagogy and the role visualization and computation can play in education. Currently, I am co-authoring an open-source materials science textbook with long-time friend and mentor Prof. W. Craig Carter. The idea is to curate some of the content we\u0026rsquo;ve developed teaching through the years, into a cohesive collection of computational notebooks which would guide undergraduate and first-year graduate students in materials science and engineering programs.\nAn example such computational essay on the Lennard-Jones interatomic potential using open-source, client-based, interactive simulations can be found here.\nIn the spring of 2022 I was the lead instructor for an MIT-course called 3.029 \u0026ndash; Mathematics and Computational Thinking for Materials Scientists and Engineers I where we piloted some of this content to sophomores learning thermodynamics and polymer synthesis. The resulting notebooks are freely-available on the class website.\n","href":"/research-topics/materials-science-pedagogy/","title":"Materials Science Pedagogy"},{"content":"","href":"/publications/acta-materialia-210-116831-2021/","title":"Acta Materialia 210, 116831 (2021)"},{"content":"","href":"/publications/nat-commun-12-1290-2021/","title":"Nat Commun 12, 1290 (2021)"},{"content":"","href":"/publications/nat-commun-11-4710-2020/","title":"Nat Commun 11, 4710 (2020)"},{"content":"","href":"/publications/acs-nano-14-7-2020/","title":"ACS nano 14, 7 (2020)"},{"content":"","href":"/publications/applied-physics-reviews-7-031402-2020/","title":"Applied Physics Reviews 7, 031402 (2020)"},{"content":"","href":"/publications/advanced-functional-materials-30-36-2020/","title":"Advanced Functional Materials 30, 36 (2020)"},{"content":"","href":"/publications/science-advances-6-15-2020/","title":"Science advances 6, 15 (2020)"},{"content":"","href":"/publications/phys-rev-b-100-115402-2019/","title":"Phys Rev B, 100, 115402 (2019)"},{"content":"","href":"/publications/nat-nanotechnol-14-967-2019/","title":"Nat Nanotechnol 14, 967 (2019)"},{"content":"","href":"/publications/science-365-6449-2019/","title":"Science 365, 6449 (2019)"},{"content":"","href":"/publications/nat-commun-10-869-2019/","title":"Nat Commun 10, 869 (2019)"},{"content":"","href":"/page/","title":"Pages"},{"content":"","href":"/search/","title":"Search"}]