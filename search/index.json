[{"content":"ðŸ‘‹ Hi there! My name is Georgios, which I\u0026rsquo;ve been told sounds uncannily similar to how one would pronounce \u0026ldquo;George(ous)\u0026rdquo;, but I go by George.\nI\u0026rsquo;m a postdoctoral Miller research fellow working primarily in materials science and condensed-matter physics, but I\u0026rsquo;m easily distracted so you might see various (seemingly) unrelated projects/musings here.\nFeel free to look around and if anything catches your eye, or you think we could work together, please leave a comment or drop me a line.\nResearch Interests Electron Hydrodynamics Advanced Characterization Spatially Resolved Transport Materials Science Pedagogy Musings Counting Digits of Pi Generative Art Geographic Map Distortions Yoga Poses Constellations ","href":"/","title":"Home"},{"content":"","href":"/research-topics/","title":"Research Topics"},{"content":"For a complete list of publications, please see my Google Scholar profile.\n","href":"/publications/","title":"Publications"},{"content":"","href":"/musings/","title":"Musings"},{"content":"I\u0026rsquo;m originally from Cyprus where I grew up and studied before moving to the US to obtain my BS in materials science \u0026amp; engineering and BS in civil \u0026amp; environmental engineering from MIT in 2017. Enamored with the Boston weather, I decided to stay at MIT to pursue my graduate studies in the department of Materials Science, where I recently defended my thesis entitled \u0026ldquo;Electron Hydrodynamics in Crystalline Solids\u0026rdquo;.\nCurrently, I\u0026rsquo;m a postdoctoral Miller research fellow at the University of California, Berkeley \u0026ndash; co-hosted by Prof. Mary Scott in MSE and Prof. Joel Moore in Physics \u0026ndash; where I\u0026rsquo;m developing new computational imaging modalities to observe current densities in anisotropic electron fluids with high spatial resolution using a transmission electron microscope.\nWhen I don\u0026rsquo;t have my science cap on, I enjoy camping, teaching generative art, and singing along to musical theater videos.\n","href":"/about/","title":"About"},{"content":"","href":"/authors/","title":"Authors"},{"content":"Introduction As part of the MIT course 3.029 I taught in the spring of 2022, we held optional coding \u0026ldquo;get-togethers\u0026rdquo; once a week, alternating between \u0026ldquo;Data-Visualization Hour\u0026rdquo; and \u0026ldquo;Code Show and Tell\u0026rdquo;. In particular, the week of Pi day happened to fall on \u0026ldquo;Code Show and Tell\u0026rdquo; and the students thought it\u0026rsquo;d be fun to code up one of the craziest Pi-related phenomena I know.\nThis is very beautifully explained in the 3Blue1Brown video below:\nMathematica SE solution First, note that this exact question was asked on the Mathematica SE in 2020 - with a very natural numeric solution using DiscreteVariables in NDSolveValue.\nnumericSolution[d_] := Module[{ collisions = 0, m1 = 1, m2 = 100^(d - 1), x10 = 1, x20 = 2, v10 = 0, v20 = -1, tmax = 20, etot, newvelocity, vsol, sol }, etot = m1 v10^2 + m2 v20^2; newvelocity[vv1_, vv2_] := Block[{tsol}, tsol = Quiet[Solve[{m1 vn1 + m2 vn2 == m1 vv1 + m2 vv2, m1 vn1^2 + m2 vn2^2 == etot}, {vn1, vn2}]]; {vn1, vn2} /. If[Sign[tsol[[1, 1, 2]]] != Sign[vv1], tsol[[1]], tsol[[2]]] ]; sol = NDSolveValue[{ x1\u0026#39;[t] == v1[t], x2\u0026#39;[t] == v2[t], x1[0] == x10, x2[0] == x20, v1[0] == v10, v2[0] == v20, WhenEvent[x1[t] == x2[t], { collisions += 1, vsol = newvelocity[v1[t], v2[t]], v1[t] -\u0026gt; vsol[[1]], v2[t] -\u0026gt; vsol[[2]] }], WhenEvent[x1[t] == 0, { collisions += 1, v1[t] -\u0026gt; -v1[t] }]}, {x1, x2, v1, v2}, {t, 0, tmax}, DiscreteVariables -\u0026gt; {v1, v2}]; Echo[collisions]; sol ] Event-Based Elastic Collisions It\u0026rsquo;s instructive however to code this up from scratch using simple elastic collisions!\nCollision Times Consider the collison between two particles, assumed to be a distance \\( 2r \\) apart. The trajectories of the two particles can be computed using their positions, instantaneous velocities, and time:\ntrajectory1 = x1 + v1 t; trajectory2 = (x1 + Î”x) + (v1 + Î”v) t; Their separation squared is therefore given by:\nseparationSquared = Simplify[With[{delta = trajectory2 - trajectory1}, delta . delta]] \\[ (\\text{$\\Delta $x}+\\text{$\\Delta $v} t).(\\text{$\\Delta $x}+\\text{$\\Delta $v} t) \\] The Wolfram Language makes no assumptions about the dot products since we\u0026rsquo;ve kept all our variables symbolic, so let\u0026rsquo;s help it out a bit by introducing simple multiplication rules:\nseparationSquared = Distribute[separationSquared] //. { ( t a_ ) . ( t b_ ) :\u0026gt; t^2 a . b, ( a_ ) . ( t b_ ) :\u0026gt; t a . b , ( t a_ ) . ( b_ ) :\u0026gt; t a . b, ( Î”v . Î”x ) :\u0026gt; ( Î”x . Î”v ) } \\[ \\text{$\\Delta $x}.\\text{$\\Delta $x}+\\text{$\\Delta $v}.\\text{$\\Delta $v} t^2+2 t \\text{$\\Delta $x}.\\text{$\\Delta $v} \\] We\u0026rsquo;re now ready to find the collision times, i.e. the times \\( t \\) when the expression for the squared distance above equals \\( 4r^2 \\).\n{firstCollision, secondCollision} = t /. Simplify[Solve[separationSquared == (2 r)^2, t]] \\[ \\left\\{-\\frac{\\text{$\\Delta $x}.\\text{$\\Delta $v}+\\sqrt{(\\text{$\\Delta $x}.\\text{$\\Delta $v})^2+\\text{$\\Delta $v}.\\text{$\\Delta $v} \\left(4 r^2-\\text{$\\Delta $x}.\\text{$\\Delta $x}\\right)}}{\\text{$\\Delta $v}.\\text{$\\Delta $v}}, \\frac{\\sqrt{(\\text{$\\Delta $x}.\\text{$\\Delta $v})^2+\\text{$\\Delta $v}.\\text{$\\Delta $v} \\left(4 r^2-\\text{$\\Delta $x}.\\text{$\\Delta $x}\\right)}-\\text{$\\Delta $x}.\\text{$\\Delta $v}}{\\text{$\\Delta $v}.\\text{$\\Delta $v}} \\right\\} \\] Note that since our equation is quadratic in time, there are two collision solutions. It\u0026rsquo;s probably easiest to show their difference graphically using an example:\nWe\u0026rsquo;re interested in the first collision time, when the particles first touch: The second collision time corresponds to the time the particles have separated again post-collision, had they been allowed to pass straight through each other: We can now write a function which returns the collision time:\nparticleParticleCollisionTime[{p1 : {m1_, x1_, v1_}, p2 : {m2_, x2_, v2_}}] := Block[{dummyMass, dx, dv, dxdv, dvdv, dxdx, rootTerm}, {dummyMass, dx, dv} = p2 - p1; dxdv = dx . dv; If[dxdv \u0026gt;= 0, Return[\\[Infinity]]]; dxdx = dx . dx; dvdv = dv . dv; rootTerm = dxdv^2 + (dvdv (1 - dxdx)); If[rootTerm \u0026lt; 0, Return[\\[Infinity]]]; -(dxdv + Sqrt[rootTerm])/dvdv ] Note that we\u0026rsquo;ve assumed the particles have a radius \\( r=1/2 \\) for simplicity and instructed our function to return Infinity if our particles are moving away from each other and will not collide.\nThis allows us to write a simple function to return the position of particles at time \\( t \\):\nparticleStateAtTime[particle : {m_, x_, v_}, time_] := {m, x + time v, v} Velocities Post-Collision The velocities post-collision are given using energy and momentum conservation:\nconservationLaws[1] = { m[1] u[1] + m[2] u[2] == m[1] v[1] + m[2] v[2], 1/2 m[1] u[1]^2 + 1/2 m[2] u[2]^2 == 1/2 m[1] v[1]^2 + 1/2 m[2] v[2]^2 }; Solve[conservationLaws[1], {v[1], v[2]}] \\[ \\begin{matrix} \\left\\{v(1)\\rightarrow u(1),v(2) \\rightarrow u(2)\\right\\} \\\\ \\left\\{ v(1)\\rightarrow \\frac{m(1) u(1)-m(2) u(1)+2 m(2) u(2)}{m(1)+m(2)}, v(2)\\rightarrow \\frac{2 m(1) u(1)-m(1) u(2)+m(2) u(2)}{m(1)+m(2)}\\right\\} \\end{matrix} \\] This generalizes nicely to higher dimensions:\nbounceVelocitiesAfterCollision[{p1 : {m1_, x1_, v1_}, p2 : {m2_, x2_, v2_}}] := Block[{dv = v2 - v1, dx = x2 - x1, deltaV, \\[Mu] = m1 m2/(m1 + m2), \\[Delta]v}, \\[Delta]v = (dv . dx (dx))/dx . dx; { {m1, x1, v1 + (2 \\[Mu])/m1 \\[Delta]v}, {m2, x2, v2 - (2 \\[Mu])/m2 \\[Delta]v} } ] It would be convenient if we could treat particle-wall collisions using our existing framework. To do so, we consider an \u0026ldquo;immovable\u0026rdquo; wall as a stationary object with Infinite mass. This requires we specialize our two functions above using pattern matching (mathematica\u0026rsquo;s analogue of multiple dispatch):\nbounceVelocitiesAfterCollision[{p1 : {\\[Infinity], x1_, v1_}, p2 : {m2_, x2_, v2_}}] := Block[{dv = v2, dx = x2 - x1, deltaV, \\[Delta]v}, \\[Delta]v = (dv . dx (dx))/dx . dx; { {\\[Infinity], x1, v1}, {m2, x2, v2 - 2 \\[Delta]v} } ] bounceVelocitiesAfterCollision[{p1 : {m1_, x1_, v1_}, p2 : {\\[Infinity], x2_, v2_}}] := Block[{dv = -v1, dx = x2 - x1, deltaV, \\[Delta]v}, \\[Delta]v = (dv . dx (dx))/dx . dx; { {m1, x1, v1 + 2 \\[Delta]v}, {\\[Infinity], x2, v2} } ] Colliding Blocks Setup As we alluded to above, we\u0026rsquo;ll consider three \u0026ldquo;blocks\u0026rdquo;:\nAn \u0026ldquo;immovable\u0026rdquo; rigid block (wall) at \\( x = \\{-1/2\\} \\) An initially stationary (blue) block with \\( m = 1 \\), at \\( x = \\{2\\} \\) A (red) block with \\( m = 100^{d-1} \\), at \\( x = \\{5\\} \\), moving to the left with \\( v = \\{-1\\} \\) particleStates[d_] := { {\\[Infinity], {-1/2}, {0}}, {1, {2}, {0}}, {100^(d - 1), {5}, {-1}} } As such, we have two possible collisions to consider:\nBlue block colliding with the wall Blue block colliding with the red block At each iteration, we will:\nCompute the two possible collision times Pick the smallest time Update the positions and velocities post-collision Rinse and repeat findShortestCollisionTime[{t_, particleStates : {wall_, blue_, red_}}] := Block[{wallBlue, blueRed}, wallBlue = particleParticleCollisionTime[{wall, blue}]; blueRed = particleParticleCollisionTime[{blue, red}]; {Min[{wallBlue, blueRed}], Ordering[{wallBlue, blueRed}]} ] bounceParticlesAtShortestCollision[{t_, particleStates : {wall_, blue_, red_}}] := Block[{time, ordering, preWall, preBlue, preRed, post}, {time, ordering} = findShortestCollisionTime[{t, particleStates}]; If[time == \\[Infinity], Return[{t, particleStates}]]; {preWall, preBlue, preRed} = particleStateAtTime[#, time] \u0026amp; /@ particleStates; post = Switch[ordering, {1, 2}, Append[bounceVelocitiesAfterCollision[{preWall, preBlue}], preRed], {2, 1}, Prepend[bounceVelocitiesAfterCollision[{preBlue, preRed}], preWall] ]; {t + time, post} ] The \u0026lsquo;do-nothing\u0026rsquo; clause inside our function above, ensures that if both collision times are Infinity, then the particle state returns unchanged. This allows us to use FixedPointList to conveniently exhaust the simulation until both our blocks fly away towards the right, terminating the simulation:\neventsList[digits_] := N[Most[FixedPointList[ bounceParticlesAtShortestCollision, {0, N[particleStates[digits]]}]]] Visualization Functions Finally, we write two utility functions to build a linear interpolation on the blocks\u0026rsquo; positions given our collisions event list:\npositionsInterpolator[listOfEvents_] := With[{ times = listOfEvents[[All, 1]], positions1D = Transpose[listOfEvents[[All, 2, All, 2, 1]]] }, Table[Interpolation[Transpose[N[{times, positions}]], InterpolationOrder -\u0026gt; 1], {positions, positions1D}] ] visualizeBlocks[t_, times_][{wall_InterpolatingFunction, blue_InterpolatingFunction, red_InterpolatingFunction}] := Graphics[{ {EdgeForm[Directive[Black, Dashed]], FaceForm[None], Rectangle[{-10, -10}, {0, 10}]}, {Blue, Rectangle[{blue[t] - 1/2, -1/2}, {blue[t] + 1/2, 1/2}]}, {Red, Rectangle[{red[t] - 1/2, -1/2}, {red[t] + 1/2, 1/2}]} }, PlotRange -\u0026gt; {{-1, 12}, {-1, 1}}, PlotLabel -\u0026gt; StringTemplate[\u0026#34;Collisions:`1`\u0026#34;][ First[FirstPosition[times, ts_ /; ts \u0026gt; t, {Length[times] + 1}]] - 2] ] Animation We can wrap everything together to produce animations of the sort:\nModule[{ events = eventsList[3], interpolators, times }, times = events[[All, 1]]; interpolators = positionsInterpolator[events]; Animate[visualizeBlocks[t, times][interpolators], {{t, 0, \u0026#34;Time\u0026#34;}, 0, Last[times]}, AnimationRepetitions -\u0026gt; 1, Paneled -\u0026gt; False, AnimationRunning -\u0026gt; False] ] ","href":"/musings/counting-digits-of-pi/","title":"Counting Digits of Pi"},{"content":"","href":"/authors/georgiosvarnavides/","title":"georgiosvarnavides"},{"content":"Together with some friends in the DMSE department, I\u0026rsquo;ve been teaching a generative art workshop during MIT\u0026rsquo;s Independent Activity Period (IAP) for the past 5 years. IAP 2022 was the fifth* iteration of the workshop (previously taught in 2017 and 2018 with Emma Vargo, 2020 with Amina Matt, Jovana and Nina Andrejevic, and 2021 with Jovana and Nina).\nThe 4-day workshop walks through python and Wolfram Language notebooks, covering the following broad topics:\nGeometric Fractals \u0026amp; L-Systems Strange Attractor \u0026amp; Wallpaper Groups Cellular Automata \u0026amp; Discrete Physical Systems Continuous Physical Systems \u0026amp; Reaction-Diffusion Systems You can find the most recent notebooks on the 2022 workshop website, as well as peruse the 2020 and 2022 workshop galleries.\n* All instructors have recently graduated from MIT. If you\u0026rsquo;re an MIT-affiliate and interested in teaching this in IAP 2023, please reach out \u0026ndash; we will be happy to help and share our notebooks/experience.\n","href":"/musings/generative-art/","title":"Generative Art"},{"content":"","href":"/publications/front-neurosci-16-901108-2022/","title":"Front Neurosci 16:901108 (2022)"},{"content":"","href":"/publications/arxiv2204.06004-2022/","title":"arXiv:2204.06004 (2022)"},{"content":"","href":"/publications/phys-rev-mater-6-045002-2022/","title":"Phys Rev Mater 6, 045002 (2022)"},{"content":"Iâ€™ve long been fascinated with transportation maps, and in particular the revolutionary re-design of the london-underground map by Harry Beck in 1933. In his iconic design, which has since been adopted by most transportation maps, Harry Beck deliberately sacrifices geographic accuracy for visual clarity of information - by using equally-spaced stations on straight lines with only 45/90 degree bends.\nIn this Wolfram Community post, we investigate how the local coordinate system is additionally distorted through the years as more stations get added to display the information more clearly.\n","href":"/musings/geographic-map-distortions/","title":"Geograghic Map Distortions"},{"content":"","href":"/publications/phys-rev-mater-5-l091202-2021/","title":"Phys Rev Mater 5, L091202 (2021)"},{"content":"","href":"/publications/nat-phys-17-1216-1220-2021/","title":"Nat Phys, 17, 1216â€“1220 (2021)"},{"content":"","href":"/publications/sci-adv-7-eabi6699-2021/","title":"Sci Adv 7, eabi6699 (2021)"},{"content":"","href":"/publications/arxiv2109.00550-2021/","title":"arXiv:2109.00550 (2021)"},{"content":"","href":"/publications/nat-commun-12-4799-2021/","title":"Nat Commun 12, 4799 (2021)"},{"content":"","href":"/publications/angew-chem-int-ed-2021/","title":"Angew. Chem. Int. Ed. (2021)"},{"content":"At its first meeting in 1922, the International Astronomical Union (IAU), officially adopted the list of 88 constellations that we use today. These include 14 men and women, 9 birds, two insects, 19 land animals, 10 water creatures, two centaurs, one head of hair, a serpent, a dragon, a flying horse, a river and 29 inanimate objects. As many of us have (frustratingly) witnessed first hand while star-gazing - most of these bear little resemblance to their supposed figures. Instead, it is more likely that the ancient constellation-makers meant them to be symbolic, a kind of celestial \u0026ldquo;Hall of Fame\u0026rdquo; for their favorite animals or heroes.\nThis begs two questions I sought to answer with this old post of mine on Wolfram Community:\nCan we \u0026lsquo;do better\u0026rsquo; now with Wolfram Language\u0026rsquo;s StarData[] curated data and Machine Learning functionality? What if the ancient constellation-makers were slightly more creative? Say they looked up at the sky, and only saw yoga-poses! ","href":"/musings/yoga-poses-constellations/","title":"Yoga Poses Constellations"},{"content":"In most conductors at room-temperature, electron collisions are akin to billiard balls, resulting in the macroscopic observation of diffusive flow (Ohm\u0026rsquo;s \u0026ldquo;law\u0026rdquo;). Recently, spatially-resolved transport measurements have revealed electrons in strongly-interacting materials can behave akin to classical fluids, confirming theoretical predictions over fifty years old.\nI study these \u0026ldquo;hydrodynamic\u0026rdquo; electron flows across various length scales, from their microscopic origins, to mesoscopic finite-size effects, and to their macroscopic observables. Recently, I was part of a team which imaged these flows in a 3D conductor for the first time, corroborating a newly-proposed electron interaction mechanism mediated by lattice vibrations.\nCurrently, as a postdoctoral Miller research fellow, I\u0026rsquo;m developing computational imaging techniques to correlate such non-uniform current densities with the underlying structure, opening the door to investigating the role of structure and defects in designing near-dissipation-less electronics and inviting questions like \u0026ldquo;does current flow around defects in materials similar to how rivers flow past pebbles? If so, can we engineer them to minimize thermal dissipation?\u0026rdquo;\n","href":"/research-topics/electron-hydrodynamics/","title":"Electron Hydrodynamics"},{"content":"I have long been fascinated by materials characterization, and in-particular the ability to image atoms and nanoscale phenomena at high spatial resolution. In many scenarios, the best way to do that is using transmission electron microscopy (TEM).\nIn my PhD work, I have collaborated with experimentalists to directly image moirÃ¨ superlattices at the interface of 2D/3D materials and investigate phonon localization at the interface between two 2D materials with high-resolution (S)TEM-based techniques.\nCurrently, as a postdoctoral Miller research fellow, I\u0026rsquo;m developing computational imaging techniques to image the induced magnetic fields arising in hydrodynamic electron flows with nanoscale resolution, using a recently-developed TEM-based technique called \u0026lsquo;Vector-field electron tomography\u0026rsquo; and electron ptychography.\n","href":"/research-topics/advanced-characterization/","title":"Advanced Characterization"},{"content":"During the course of my PhD, I developed an open-source software package called SpaRTaNS to perform spatially-resolved transport by solving the steady-state Boltzmann transport equation in three real-space and three momentum-space dimensions.\nSpaRTaNS is \u0026ldquo;carrier-agnostic\u0026rdquo; with applications in phonon (heat) transport (e.g thermal interface resistance of semi-coherent interfaces), as-well as electron (charge) transport (e.g the importance of microscopic interactions in electron hydrodynamic flows). SpaRTaNS can be run on anything from a laptop to high-performance computing systems, and provides a flexible API for specifying custom boundary conditions, collision operators, geometries, state spaces, and more.\n","href":"/research-topics/spatially-resolved-transport/","title":"Spatially Resolved Transport"},{"content":"I spend a great deal of my time thinking about pedagogy and the role visualization and computation can play in education. Currently, I am co-authoring an open-source materials science textbook with long-time friend and mentor Prof. W. Craig Carter. The idea is to curate some of the content we\u0026rsquo;ve developed teaching through the years, into a cohesive collection of computational notebooks which would guide undergraduate and first-year graduate students in materials science and engineering programs.\nAn example such computational essay on the Lennard-Jones interatomic potential using open-source, client-based, interactive simulations can be found here.\nIn the spring of 2022 I was the lead instructor for an MIT-course called 3.029 \u0026ndash; Mathematics and Computational Thinking for Materials Scientists and Engineers I where we piloted some of this content to sophomores learning thermodynamics and polymer synthesis. The resulting notebooks are freely-available on the class website.\n","href":"/research-topics/materials-science-pedagogy/","title":"Materials Science Pedagogy"},{"content":"","href":"/publications/acta-materialia-210-116831-2021/","title":"Acta Materialia 210, 116831 (2021)"},{"content":"","href":"/publications/nat-commun-12-1290-2021/","title":"Nat Commun 12, 1290 (2021)"},{"content":"","href":"/publications/nat-commun-11-4710-2020/","title":"Nat Commun 11, 4710 (2020)"},{"content":"","href":"/publications/acs-nano-14-7-2020/","title":"ACS nano 14, 7 (2020)"},{"content":"","href":"/publications/applied-physics-reviews-7-031402-2020/","title":"Applied Physics Reviews 7, 031402 (2020)"},{"content":"","href":"/publications/advanced-functional-materials-30-36-2020/","title":"Advanced Functional Materials 30, 36 (2020)"},{"content":"","href":"/publications/science-advances-6-15-2020/","title":"Science advances 6, 15 (2020)"},{"content":"","href":"/publications/phys-rev-b-100-115402-2019/","title":"Phys Rev B, 100, 115402 (2019)"},{"content":"","href":"/publications/nat-nanotechnol-14-967-2019/","title":"Nat Nanotechnol 14, 967 (2019)"},{"content":"","href":"/publications/science-365-6449-2019/","title":"Science 365, 6449 (2019)"},{"content":"","href":"/publications/nat-commun-10-869-2019/","title":"Nat Commun 10, 869 (2019)"},{"content":"","href":"/page/","title":"Pages"},{"content":"","href":"/search/","title":"Search"}]